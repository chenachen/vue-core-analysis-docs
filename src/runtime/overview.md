# 总览

::: warning
本章开始，不再具体到每个文件每行代码都进行解读。

原因主要是代码量太大，且很多代码是重复的模式，每行代码去看去解读的投入产出比相对于响应式核心来说较低。

所以我们读运行时以及后面的编译器章节时，更多的是去看整体的架构设计和模块划分，理解各个模块的职责和它们之间的协作关系。
:::

## 📦 目录解析

运行时主要包含两个包

- `packages/runtime-core`： 核心运行时逻辑，不依赖任何平台相关的 API。主要负责组件实例、渲染器接口、虚拟 DOM、调度与更新等平台无关逻辑。
- `packages/runtime-dom`：基于`runtime-core`，实现浏览器 DOM 相关的 API。

## 阅读思路

### 🧭 一、先搭建“地图”，知道运行时在干什么

运行时的职责其实可以抽象成一句话： **把响应式系统的变化映射到真实的 UI 上。**

这句话拆开就是几块核心逻辑：

- 挂载根组件（createApp）
- 创建渲染器（createRenderer）
- 初始化组件实例
- 创建并渲染虚拟 DOM（VNode）
- 响应式变更触发更新
- 卸载 / 重新渲染

### 🧠 二、带着执行流程读，而不是一个文件一个文件啃

根据上面这个核心逻辑，我打算以一个大致的执行顺序去阅读运行时源码：

- [从createApp开始](./createApp.md): 应用的入口
- [baseCreateRenderer](./baseCreateRenderer.md): 创建渲染器，渲染虚拟节点
- [createVnode](./createVNode.md): 如何将根节点解析为虚拟节点
- [Diff算法](./diff.md): 响应式变更时，如何高效更新虚拟节点
- [组件实例化](./componentInstance.md): 组件是如何被实例化和挂载的
- [生命周期](./lifecycle.md): 组件的生命周期是如何被触发的

最后，我会补充部分api和细节的解读：
- todo